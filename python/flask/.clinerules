# Secure Python Flask Application Development Rules

## Foundational Instructions for LLM-based Secure Code Generation

*   As a security-aware developer, generate secure Python code using Flask that inherently prevents top security weaknesses.
*   Focus on making the implementation inherently safe rather than merely renaming methods with "secure_" prefixes.
*   Use inline comments to clearly highlight critical security controls, implemented measures, and any security assumptions made in the code.
*   Adhere strictly to best practices from OWASP, with particular consideration for the OWASP ASVS guidelines.
*   **Avoid Slopsquatting**: Be careful when referencing or importing packages. Do not guess if a package exists. Comment on any low reputation or uncommon packages you have included.

## Memory Safety Consideration
*   Python is a memory-safe language; therefore, explicit rules for memory safety considerations are not required.

## Top CWEs for Python + Flask Applications

### CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
**Summary:** Untrusted data is improperly neutralized before being included in a web page, allowing malicious scripts to be executed.
**Mitigation Rule:** Always use Flask's Jinja2 templating engine with default autoescaping enabled, which mitigates XSS by escaping special characters. For dynamic content where autoescaping is insufficient (e.g., user-provided rich text), use a dedicated, well-vetted HTML sanitization library like `Bleach` to strip malicious tags and attributes.

### CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')
**Summary:** An application constructs all or part of an SQL query using externally-influenced input, allowing attackers to modify query logic.
**Mitigation Rule:** Utilize an Object-Relational Mapper (ORM) such as SQLAlchemy and exclusively use its parameterized query or prepared statement capabilities. Never construct SQL queries by concatenating user-supplied input strings directly.

### CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
**Summary:** An application uses externally-controlled input to construct a pathname, potentially allowing access to files outside an intended directory.
**Mitigation Rule:** When handling file paths based on user input, strictly validate and sanitize the input, then use `werkzeug.utils.safe_join` or `os.path.join` with a predefined, absolute base directory. Never directly combine unsanitized user input with file system operations.

### CWE-352: Cross-Site Request Forgery (CSRF)
**Summary:** A web application does not sufficiently verify that a request was intentionally generated by a legitimate user.
**Mitigation Rule:** Implement CSRF protection for all state-changing requests (e.g., POST, PUT, DELETE) by integrating Flask-WTF's `CSRFProtect` extension, which automatically generates and validates CSRF tokens.

### CWE-287: Improper Authentication
**Summary:** An application fails to authenticate or incorrectly authenticates users, leading to unauthorized access.
**Mitigation Rule:** Implement robust user authentication using secure libraries like Flask-Login for session management. For password storage, use strong, modern hashing algorithms provided by libraries like `Flask-Bcrypt` or `passlib` (preferring Argon2 or bcrypt), never storing plain-text passwords.

### CWE-20: Improper Input Validation
**Summary:** An application does not validate or incorrectly validates input, leading to various vulnerabilities.
**Mitigation Rule:** Perform strict server-side validation on all user input, regardless of client-side validation. Utilize robust validation libraries like Flask-WTF/WTForms or Pydantic to enforce expected data types, formats, lengths, and ranges. Reject invalid input explicitly and early.

### CWE-522: Insufficiently Protected Credentials
**Summary:** An application stores or transmits credentials in an insecure manner, making them susceptible to compromise.
**Mitigation Rule:** Never hardcode sensitive credentials (e.g., API keys, database passwords, Flask `SECRET_KEY`) directly in the source code. Retrieve all secrets from environment variables, a dedicated secure secrets management service (e.g., HashiCorp Vault, AWS Secrets Manager), or, during development, from a `.env` file which must be excluded from version control (`.gitignore`). Access them via `os.environ` or `app.config`.
